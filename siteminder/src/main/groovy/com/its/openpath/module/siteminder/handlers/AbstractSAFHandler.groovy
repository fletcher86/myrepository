package com.its.openpath.module.siteminder.handlers

import groovy.util.slurpersupport.GPathResult

import java.util.concurrent.Executors
import java.util.concurrent.ScheduledExecutorService
import java.util.concurrent.TimeUnit

import javax.ws.rs.core.Response

import org.apache.cxf.helpers.IOUtils
import org.apache.cxf.jaxrs.client.WebClient
import org.slf4j.Logger
import org.slf4j.LoggerFactory
import org.springframework.beans.factory.annotation.Value

import com.its.openpath.module.opscommon.comm.bus.IMessageBus
import com.its.openpath.module.opscommon.event.persistence.AbstractEventPersistenceHandler
import com.its.openpath.module.opscommon.model.messaging.ops.OpsMessage
import com.its.openpath.module.opscommon.util.OpsStatuses
import com.its.openpath.module.opscommon.util.StatusMonitoringEventMessageBusQueueNames
import com.its.openpath.module.opscommon.util.TimeUUIDUtils
import com.its.openpath.module.siteminder.subscribers.TrustManagerManipulator


abstract class AbstractSAFHandler extends AbstractEventPersistenceHandler
{
  private static final Logger sLogger = LoggerFactory.getLogger( AbstractSAFHandler.class.name )
  
  public final ScheduledExecutorService mScheduler = Executors.newSingleThreadScheduledExecutor()
  
  private @Value("#{runtimeProperties['siteminder.base.url']}")
  String mSiteminderBaseURL
  
  private @Value("#{runtimeProperties['reztrip.base.url']}")
  String mReztripBaseURL
  
  private @Value("#{runtimeProperties['reztrip.confirmReservations.uri']}")
  String mReztripConfirmReservationsURI
 
  
  // The URL or POST header values doesn't change per-request, so using an instance like this is thread safe
  private WebClient mSiteminderWSClient = WebClient.create( "$mSiteminderBaseURL" )
  
  private WebClient mReztripWSClient = WebClient.create ( "$mReztripBaseURL" )
  
  /**
   * DEFINE A BUNCH OF X'S FOR LOGGING PURPOSES FOR ERRORS
   */
  public static final String A_BUNCH_OF_XS =  "XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX"

  
  AbstractSAFHandler()
  {
    super()
    sLogger.info "Instantiated ..."
  }
  
  Closure checkStatus =
  {
    if(sLogger.isDebugEnabled ())
      sLogger.debug(this.getSubscriberId() +" -> Checking for [${sStatus}] transactions <-")
    try
    {
      List<UUID> list = super.getRowIdsWithStatus(sStatus)
      if(list!=null && list.size>0)
      {
        switch (sStatus)
        {
          case OpsStatuses.CONFIRM_RESERVATIONS :
            for(UUID uuid : list)
            {
              sleep(3000)
              publishMessage(uuid, StatusMonitoringEventMessageBusQueueNames.RESERVATIONS_CONFIRMATION_NOTIF_REQUEST, 0, "", "n/a", "n/a", "n/a")
            }
            break
          case OpsStatuses.FAILURE :
            for(UUID uuid : list)
            {
              sleep(3000)
              publishMessage(uuid, StatusMonitoringEventMessageBusQueueNames.TXN_RETRY, 0, "n/a", "n/a", "n/a", "n/a")
            }
            break
          case OpsStatuses.IN_PROGRESS :
            for (UUID uuid : list)
            {
              sleep(3000)
              publishMessage(uuid, StatusMonitoringEventMessageBusQueueNames.IN_PROGRESS_MONITOR, 0, "n/a", "n/a", "n/a", "n/a")
            }
        }
      }
    }
    catch (Throwable e)
    {
      sLogger.error("Error getting records with status of [${sStatus}]", e)
    }
  }
  
  /**
   * Publish event OpsMessage to message bus
   * <p />
   * @param uuid UUID, time base uuid generated by TimeUUIDUtils
   * @param queueName String, message bus queue name
   * @param messageType Integer, messageType from enum
   * @param source String, source of the event
   * @param destination String, destination of the event
   * @param data String, the payload for this event
   */
  def void publishMessage( UUID uuid, String queueName, Integer messageType, String messageSubType, String source, String destination, String data )
  {
    OpsMessage msg = new OpsMessage()
    msg.messageType = messageType
    msg.messageSubType = messageSubType
    msg.source = source
    msg.destination = destination
    msg.correlationId = uuid.toString()
    msg.correlationIdBytes = TimeUUIDUtils.asByteString( uuid )
    msg.timestamp = TimeUUIDUtils.getTimeFromUUID( uuid )
    msg.data = data
    mOpsMessageBus.queueMessage( queueName, msg )
  }
  
  public void postJsonRezTripForConfirmation(UUID uuid, String msg, Closure handleError)
  {
    WebClient client = mReztripWSClient
    String reztripUrl = "$mReztripBaseURL$mReztripConfirmReservationsURI"
    client.path( reztripUrl )
    client.type( "application/json" ).accept( "application/json" )

    Response response
    try
    {
      response = client.post( msg )
      
      if ( response.status != 200 )
      {
        /*
         * HANDLE 400 & 500 ERRORS (Not 200 that is)
         */
        handleError.call( response.status, reztripUrl)
        return
      }
      /*
       * OTHERWISE CONTINUE PROCESSING RESPONSE
       */
      InputStream inputStream = (InputStream) response.getEntity()
      String responseJson = IOUtils.toString( inputStream )
      super.updateTransactionStatus ( uuid, OpsStatuses.WAITING_FOR_CONFIRMED_RESERVATIONS )
    }
    catch (Throwable e)
    {
      sLogger.error("Error on retry status of [${sStatus}]", e)
    }
    
  }
  
  
  public void confirmed(UUID uuid, String msg, Closure handleError)
  {
    WebClient client = mSiteminderWSClient
    client.path( "${mSiteminderBaseURL}" )
    Response response
 
    try
    {
      client.type( "application/xml" ).accept( "application/xml" )
      response = client.post( msg )
      
      if ( response.status != 200 )
      {
        /*
         * HANDLE 400 & 500 ERRORS (Not 200 that is)
         */
        handleError.call( response.status, mSiteminderBaseURL)
        return
      }
      /*
       * OTHERWISE CONTINUE PROCESSING RESPONSE
       */
      InputStream inputStream = (InputStream) response.getEntity()
      String responseJson = IOUtils.toString( inputStream )
      
      sLogger.info("Success occurred this time on request [${uuid}] retry. [${sStatus}]")
      super.updateTransactionStatus ( uuid, OpsStatuses.SUCCESS )
    }
    catch (Throwable e)
    {
      sLogger.error("Error on retry status of [${sStatus}]", e)
    }
    
  }
  
  /**
   * Post string to site minder endpoint
   * <p />
   * @param uuid universal unique id
   * @param notifJSON String
   * @param type OpsTxnType
   */
  public void postXmlSiteMinder( UUID uuid, String xmlMessage, Closure handleError)
  {
    
    WebClient client = mSiteminderWSClient
    client.path( "${mSiteminderBaseURL}" )
    Response response
    try
    {
      client.type( "application/xml" ).accept( "application/xml" )
      response = client.post( xmlMessage )
      
      if ( response.status != 200 )
      {
        /*
         * HANDLE 400 & 500 ERRORS
         */
        handleError.call( response.status, mSiteminderBaseURL)
        return
      }
      /*
       * OTHERWISE CONTINUE PROCESSING RESPONSE XML AND HANDLE EXPECTED ERRORS APPROPRIATELY
       */
      InputStream inputStream = (InputStream) response.getEntity()
      String responseXML = IOUtils.toString( inputStream )
      super.incrementIntColumn(uuid, "numretries")
      
      GPathResult res = new XmlSlurper().parseText( responseXML ).declareNamespace('SOAP-ENV': 'http://schemas.xmlsoap.org/soap/envelope/' )
      GPathResult errors = res.children().find( {it.name() ==  "Errors"} )
      if(!errors.isEmpty() )
      {
        sLogger.info("Error still occuring on request [${uuid}] retry. [${sStatus}]")
      }
      else
      {
        sLogger.info("Success occurred this time on request [${uuid}] retry. [${sStatus}]")
        super.updateTransactionStatus ( uuid, OpsStatuses.SUCCESS )
      }
    }
    catch (Throwable e)
    {
      sLogger.error("Error on retry status of [${sStatus}]", e)
    }
  }
  
  public void init()
  {
    def takeAction = new TakeActionOnStatusThread(checkStatus)
    takeAction.setTakeActionBeforeItsTooLate(checkStatus)
    mScheduler.scheduleWithFixedDelay( takeAction, 20, 20, TimeUnit.SECONDS )
  }
}
